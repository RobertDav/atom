SocketServer 启动流程
  根据配置参数创建一个 requestChannel ，M个Acceptor，M*N个Processor,
  其中M是监听地址的数量 N是num.network.thread 配置的 acceptor对应的Processors的数量
每个监听地址除了ip和port之外 还有协议类型以及名称， 这些共同组成endPoint类
  socketServer 保存endpoint 到Acceptor的映射和Processor.id到processor的映射
  requestChannel持有M*N个processor的id到其自身的映射
  每个Acceptor 持有1个Selector
  每个Acceptor 持有1个监听EndPoint 的ServerSocketChannel
  每个Acceptor 持有N个Processor组成的数组
  每个processor 持有1个Selector(kafka自己实现的selectable接口)
  每个processor 持有一组socket连接
  acceptors和processors 都启动了线程(M*(N+1))构成了整个网络层的处理

网络层的运转核心还是 Acceptor 和processor的线程函数


Acceptor Run 总结 extends runbale
1. 循环，从selector 中等待I/O事件就绪
2. 遍历所有的I/O事件 将 isAcceptable 的套接字取出，并调用socket的accept() 取得新连接
3. 检查最大连接数，没超限得话进行一些socket选项配置
4. 将配置后的socket存入processor的内部队列中

可以看到acceptor仅仅做了中介的作用，它是直接和客户端的连接请求打交道的，将成功的连接处理后传递给processor，这样processor就可以专心去处理网络数据的读写
另一方面 channel 其实是对socket句柄的封装
socketChannel.configureBlocking(false)
// socket 设置tcp_nodelay选项 禁止nagle 算法
socketChannel.socket().setTcpNoDelay(true)
// socket 设置保活模式 长时间没有发送心跳则 发出rst包重置连接
socketChannel.socket().setKeepAlive(true)
